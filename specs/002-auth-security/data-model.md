# Data Model: Authentication & Security â€“ High-Level Todo App

**Feature**: 002-auth-security
**Date**: 2026-02-23
**Purpose**: Define authentication-related data structures, validation rules, and JWT token format

## Entity Definitions

### User Entity (Extended from Feature 001)

**Purpose**: Represents a user account with authentication capabilities

**Existing Attributes** (from Feature 001):

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | Integer | Primary Key, Auto-increment | Unique identifier |
| email | String | Required, Unique, Max 255 chars | User's email address |
| username | String | Required, Unique, Max 50 chars | User's display name |
| created_at | DateTime | Auto-generated, Not Null | Account creation timestamp |

**New Attributes** (for Authentication):

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| password_hash | String | Required, Max 255 chars | Bcrypt-hashed password |

**Validation Rules**:
- `email`: Must be valid email format (validated by Pydantic EmailStr)
- `username`: Must be 3-50 characters, alphanumeric with underscores allowed
- `password` (input only, never stored): Minimum 8 characters, at least one uppercase, one lowercase, one number
- `password_hash`: Generated by bcrypt, never exposed in API responses
- `email` and `username`: Must be unique across all users

**Indexes**:
- Primary: `id` (auto-indexed)
- Unique: `email` (for fast lookup and uniqueness enforcement)
- Unique: `username` (for fast lookup and uniqueness enforcement)

**Relationships**:
- One-to-Many with Task: One user can have many tasks (unchanged from Feature 001)

**SQLModel Definition**:
```python
from sqlmodel import Field, SQLModel, Relationship
from datetime import datetime
from typing import Optional, List

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    username: str = Field(unique=True, index=True, max_length=50)
    password_hash: str = Field(max_length=255)  # NEW FIELD
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship (unchanged)
    tasks: List["Task"] = Relationship(back_populates="user")
```

---

### JWT Token (Conceptual - Not Stored in Database)

**Purpose**: Represents an authentication token for stateless authentication

**Token Structure**:

| Field | Type | Description |
|-------|------|-------------|
| user_id | Integer | ID of the authenticated user |
| exp | Integer (Unix timestamp) | Token expiration time |
| iat | Integer (Unix timestamp) | Token issued at time |

**Token Format**:
```
Header.Payload.Signature
```

**Example Payload**:
```json
{
  "user_id": 123,
  "exp": 1708704000,
  "iat": 1708700400
}
```

**Validation Rules**:
- `user_id`: Must reference an existing user in the database
- `exp`: Must be in the future (not expired)
- `iat`: Must be in the past (token was issued before now)
- Signature: Must be valid when verified with JWT_SECRET

**Token Lifecycle**:
1. **Generation**: Created on successful login with user_id and expiration
2. **Storage**: Stored in browser (localStorage or httpOnly cookie)
3. **Transmission**: Sent in Authorization header as "Bearer {token}"
4. **Validation**: Verified on every protected API request
5. **Expiration**: Becomes invalid after expiration time
6. **Revocation**: Client-side removal on logout (no server-side storage)

---

## Authentication Schemas (Pydantic)

### UserRegister Schema

**Purpose**: Input schema for user registration

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| email | EmailStr | Required | User's email address |
| username | str | Required, 3-50 chars | User's username |
| password | str | Required, 8+ chars | User's password (plain text input) |

**Validation Rules**:
- `email`: Valid email format (Pydantic EmailStr)
- `username`: 3-50 characters, alphanumeric + underscores
- `password`: Minimum 8 characters, at least one uppercase, one lowercase, one number

**Pydantic Schema**:
```python
from pydantic import BaseModel, EmailStr, validator
import re

class UserRegister(BaseModel):
    email: EmailStr
    username: str
    password: str

    @validator('username')
    def validate_username(cls, v):
        if len(v) < 3 or len(v) > 50:
            raise ValueError('Username must be 3-50 characters')
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username must be alphanumeric with underscores')
        return v

    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'[0-9]', v):
            raise ValueError('Password must contain at least one number')
        return v
```

---

### UserLogin Schema

**Purpose**: Input schema for user login

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| email | EmailStr | Required | User's email address |
| password | str | Required | User's password (plain text input) |

**Validation Rules**:
- `email`: Valid email format
- `password`: Any string (validation happens against stored hash)

**Pydantic Schema**:
```python
class UserLogin(BaseModel):
    email: EmailStr
    password: str
```

---

### Token Schema

**Purpose**: Output schema for successful login

**Fields**:

| Field | Type | Description |
|-------|------|-------------|
| access_token | str | JWT token string |
| token_type | str | Always "bearer" |
| user | UserRead | User information |

**Pydantic Schema**:
```python
class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: UserRead
```

---

### UserRead Schema (Updated)

**Purpose**: Output schema for user information (never includes password_hash)

**Fields**:

| Field | Type | Description |
|-------|------|-------------|
| id | int | User ID |
| email | str | User's email |
| username | str | User's username |
| created_at | datetime | Account creation timestamp |

**Note**: `password_hash` is NEVER included in any response schema

**Pydantic Schema**:
```python
class UserRead(BaseModel):
    id: int
    email: str
    username: str
    created_at: datetime

    class Config:
        from_attributes = True
```

---

## Password Hashing

### Hashing Algorithm

**Algorithm**: Bcrypt
**Library**: passlib with bcrypt scheme
**Rounds**: 12 (default, provides good security/performance balance)

### Hashing Process

**Registration Flow**:
1. User submits plain text password
2. Validate password strength (8+ chars, mixed case, numbers)
3. Hash password using bcrypt: `password_hash = pwd_context.hash(password)`
4. Store `password_hash` in database
5. Never store or log plain text password

**Login Flow**:
1. User submits email and plain text password
2. Query database for user by email
3. Verify password: `is_valid = pwd_context.verify(password, user.password_hash)`
4. If valid, generate JWT token
5. If invalid, return 401 Unauthorized

### Security Properties

- **Salt**: Automatically generated and included in hash
- **Slow**: Intentionally slow to prevent brute force (12 rounds)
- **One-way**: Cannot reverse hash to get original password
- **Unique**: Same password produces different hashes due to random salt

---

## JWT Token Generation and Validation

### Token Generation

**When**: After successful login (password verification passes)

**Process**:
1. Extract user_id from authenticated user
2. Calculate expiration time (current time + JWT_EXPIRATION_HOURS)
3. Create payload: `{"user_id": user.id, "exp": exp_time, "iat": current_time}`
4. Sign payload with JWT_SECRET using HS256 algorithm
5. Return token string

**Code Example**:
```python
import jwt
from datetime import datetime, timedelta

def create_access_token(user_id: int) -> str:
    expire = datetime.utcnow() + timedelta(hours=JWT_EXPIRATION_HOURS)
    payload = {
        "user_id": user_id,
        "exp": expire,
        "iat": datetime.utcnow()
    }
    token = jwt.encode(payload, JWT_SECRET, algorithm="HS256")
    return token
```

### Token Validation

**When**: On every protected API request

**Process**:
1. Extract token from Authorization header ("Bearer {token}")
2. Decode and verify signature using JWT_SECRET
3. Check expiration time (exp > current time)
4. Extract user_id from payload
5. Optionally: Query database to verify user still exists
6. Return user_id or raise 401 Unauthorized

**Code Example**:
```python
def verify_token(token: str) -> int:
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        user_id = payload.get("user_id")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

---

## User Isolation Implementation

### Automatic Filtering

**Principle**: All data queries are automatically filtered by authenticated user_id

**Implementation**:
1. Extract user_id from validated JWT token
2. Add WHERE clause to all queries: `WHERE user_id = {authenticated_user_id}`
3. Never trust user_id from request body or query parameters
4. Return 403 Forbidden if user tries to access another user's data

**Example - Get All Tasks**:
```python
@router.get("/tasks")
def get_tasks(current_user: User = Depends(get_current_user)):
    # Automatically filter by authenticated user
    tasks = session.query(Task).filter(Task.user_id == current_user.id).all()
    return tasks
```

**Example - Get Single Task**:
```python
@router.get("/tasks/{task_id}")
def get_task(task_id: int, current_user: User = Depends(get_current_user)):
    task = session.query(Task).filter(
        Task.id == task_id,
        Task.user_id == current_user.id  # Enforce ownership
    ).first()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task
```

**Example - Create Task**:
```python
@router.post("/tasks")
def create_task(task_data: TaskCreate, current_user: User = Depends(get_current_user)):
    # Automatically set user_id from authenticated user
    task = Task(**task_data.dict(), user_id=current_user.id)
    session.add(task)
    session.commit()
    return task
```

---

## Database Migration

### Schema Changes

**Required Change**: Add `password_hash` column to `user` table

**SQL Migration**:
```sql
-- Add password_hash column
ALTER TABLE user ADD COLUMN password_hash VARCHAR(255);

-- For existing users (if any), set a temporary hash or require password reset
-- UPDATE user SET password_hash = '$2b$12$...' WHERE password_hash IS NULL;

-- Make column NOT NULL after setting values
ALTER TABLE user ALTER COLUMN password_hash SET NOT NULL;
```

**SQLModel Auto-Migration**:
- SQLModel will automatically create the column on next startup if using `create_all()`
- For production, use Alembic for proper migrations

---

## Error Handling

### Authentication Errors

**401 Unauthorized**:
- Missing Authorization header
- Invalid JWT token
- Expired JWT token
- Malformed JWT token
- Invalid signature

**403 Forbidden**:
- Valid JWT token but trying to access another user's data
- Valid JWT token but insufficient permissions (future feature)

**400 Bad Request**:
- Registration with existing email
- Registration with existing username
- Weak password (doesn't meet requirements)
- Invalid email format

**Error Response Format**:
```json
{
  "detail": "Error message here"
}
```

---

## Summary

The authentication data model extends the existing User entity with a password_hash field and introduces JWT tokens for stateless authentication. Password security is handled through bcrypt hashing, and user isolation is enforced by extracting user_id from validated JWT tokens and automatically filtering all data access. The system maintains a stateless architecture with no server-side session storage.

**Next**: Generate API contracts in contracts/ directory
